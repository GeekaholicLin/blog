深入了解 JavaScript 的双精度浮点数

在 JavaScript 中，所有的 Number 类型的数字都是以双精度浮点数的方式存储。这也带来了一些诡异的问题，比如很知名的`0.1 + 0.2 !== 0.3`。

## 存储结构

![双精度浮点数的存储结构]](http://image.geekaholic.cn/20191114154418.png@0.8)

- 符号位 S：0 代表正数，1 代表负数
- 指数位 E：中间的 11 位存储指数，用来表示次方数
- 尾数位 M：最后的 52 位是尾数，超出部分自动进 1 舍 0，（用 52 位来存储，但可表示 53 位数字）

用公式表示即为：

![公式表示 1](http://image.geekaholic.cn/20191114154505.png@0.8)

对于目前的指数位 E 而言，其能表示的范围为`[0, Math.pow(2, 11) - 1]`，也就是`[0, 2047]`。但是在科学计数法中指数是可以为负数的，所以需要减去一个偏移量`1023`（至于偏移量为什么是`1023`，暂且当作是规定），使得科学计数法中的指数能够表示的数的范围为`[-1023, 1024]`。且在二进制的科学计数法中，尾数的小数点前面必然是数字`1`，为了能够让尾数表示更多位以最大限度地提高精度，数字`1`可以省略。不省略的情况下尾数位 M 部分是 1 位整数 + 51 位小数，现如今省略掉整数则 52 位都可以表示尾数的小数部分，加上省略掉的整数`1`则可表示 53 位数字。

综上所述，公式变成了：

![公式表示 2](http://image.geekaholic.cn/20191114160844.png@0.8)

## 换算

本小节以十进制中的`173.8125`为例子进行换算。

### 手动换算

原则：整数部分使用「除 2 取余，逆序排列」，小数部分使用「乘 2 取整，顺序排列」

换算过程如下：

```plain
// 先转换整数 173，结果为 10101101
173 / 2 = 86...1
86 / 2 = 43...0
43 / 2 = 21...1
21 / 2 = 10...1
10 / 2 = 5...0
5 / 2 = 2...1
2 / 2 = 1...0
1 / 2 = 0...1

// 再转换小数 0.8125，结果为 1101
0.8125 * 2 = 1...0.625
0.625 * 2 = 1...0.25
0.25 * 2 = 0...0.5
0.5 * 2 = 1...0

// 整合整数和小数，结果为 10101101.1101
```

十进制数`173.8125`转换为二进制为`10101101.1101`，根据双精度浮点数的表达公式，则`S = 0,E = 1030, M = 0.01011011101`

### 自动换算

直接借助 [工具](http://www.binaryconvert.com/convert_double.html)，进行换算。

![换算结果](http://image.geekaholic.cn/20191114165534.png@0.8)

将上图和手动换算的结果对应起来，首先`S`为 0，而`E = 1030 = (1030).toString(2) = 10000000110`，对于`M`只取小数点后的部分`01011011101`，正好对应图片中的表示。

## 常见的值

JavaScript 内置对象 `Number` 中有一些属性，用于表示常见的常量。我们一一来看这些常量和双精度浮点数的表示方法中有什么关联。

但在开始之前，我们得先知道指数部分虽然取值范围为`[-1023, 1024]`，但是全 0 和全 1 用于其他用途，所以表示双精度浮点数的时候，有效范围为`[-1022, 1023]`

### Number.EPSILON

表示 1 和`Number`可表示大于 1 的最小浮点数的差值，大小为`2^-52`，可用于判断结果是否足够精确以致于可以当成相等，比如`Math.abs(0.1+0.2-0.3) < Number.EPSILON`。

那`Number.EPSILON`的值怎么来的？

先来看「`Number`可表示的大于 1 的最小浮点数」用双精度浮点数的存储结构怎么表示？

```plain
0 01111111111 0000000000000000000000000000000000000000000000000001
```

符号位为 0，指数部分为`parseInt(0b01111111111, 10) - 127 = 0`，尾数位 M 为`2^-52`（当然这里还原后还得加上尾数的整数部分`1`）。所以，「大于 1 的最小浮点数」为`(-1)^0 * 2^0 * (1 + 2^-52)`，得出`Number.EPSILON`为`2^-52`。

### Number.MAX_SAFE_INTEGER

表示 Number 类型中最大的安全整数，大小为`2^53-1`。

什么叫「安全」？`2^53-1`这个值怎么来的？

「安全」指的是，在浮点数存储机制中，能够与实数建立一对一映射。_这样用于计算或者比较数值的时候才是安全可靠的。_

如果要一一映射，那必须得利用尾数的有限的二进制位，也就是尾数的小数位数必须小于等于`52`。尾数 M 小数位数如果为`53`位，那么第`53`位就会因为存在自动进 1 舍 0，与其下一个数的表示（原有基础上加 1 进 1 而不是自动进 1）冲突导致不安全。

比如`2^53`和`2^53+1`，用双精度浮点数的存储结构怎么表示？

要使得公式`V = (-1)^S * 2^(E - 1023) * (1 + M)`的结果为整数，那么：

- 对于`2^53`，符号位 S 为 `0`，指数位 E 为`E = 1023+53 = 1076 = 0b10000110100`，尾数位 M 都为 `0.0{52}`
- 对于`2^53+1`，符号位 S 为`0`，指数位 E 为`E = 1023+53 = 1076 = 0b10000110100`，实际尾数位 M 为`0.0{52}1`，也就是`M = 2^-53`。但是这里会自动进 1，导致`M = 2^-52`。自动进 1 就会变成了另外一个数`2^53+2`

```plain
0 10000110100 0000000000000000000000000000000000000000000000000000
0 10000110100 0000000000000000000000000000000000000000000000000000(1) // 会自动进 1 变为下面那个
0 10000110100 0000000000000000000000000000000000000000000000000001 // 2^53+2 的表示
```

所以，为了「安全」地表示整数，整数转换为二进制后的 M 尾数不能超过 52。则「最大的安全整数」应该是`2^53 - 1`（临界点`53 位`都为 0，后退 1 步），转换为十进制则为`9007199254740991`。

### Number.MIN_SAFE_INTEGER

表示最小安全整数，值为`-(2^53 - 1)`，转换为十进制则为`-9007199254740991`

由`Number.MAX_SAFE_INTEGER`可得，符号位取反即可。

### Number.MAX_VALUE

与`Number.MAX_SAFE_INTEGER`不同，`Number.MAX_VALUE`是表示双精度浮点数能表示最大的值，**约为**`2^1024`。如果比`Number.MAX_VALUE`还大，那将被表示成`Infinity`。

那`2^1024`这个值怎么来的？

我们知道，指数部分 E 全 0 和全 1 是特殊用途，那 E 最大为`2046`，对应的指数部分为`1023`。而尾数 M 部分当然是全为 1 的时候最大。二进制表示如下：

```plain
0 11111111110 1111111111111111111111111111111111111111111111111111
```

根据公式则得出`2^1023 * (1+(2^0 - 2^52)) = 2^1024 - 2^971`。随着 M 中`1`的增多，结果就越接近`2^1024`。

### Number.MIN_VALUE

表示 JavaScript 能表示的最小正数，无限地接近 0，等于`2^-1074`。小于`Number.MIN_VALUE`的将会被转换为 0。注意，这个常量不是表示「最小数」。

那这个数`2^-1074`又是怎么来的呢？

因为常规的公式中，省略掉了尾数整数部分的`1`，是默认有`1`的存在。而最小正数，就不需要`1`，因为换成`0`反而可以更小。这种`0.xxxx`的形式表示尾数的整数与小数部分，这样的二进制浮点数也叫「非规格化」（subnormal）。

那现在我们以「非规格化」的思路来思考`Number.MIN_VALUE`的取值。

正数，符号位 S 为 0，E 部分为 0，M 第 52 位为 1。因为 E 部分使用到了全 0，这时候也叫做「Min. subnormal positive double」

```plain
0 00000000000 0000000000000000000000000000000000000000000000000001
```

结果就是`2^(0-1023) *  = 2^-1022`

// TODO:

---

参考：

* [该死的 IEEE-754 浮点数，说「约」就「约」，你的底线呢？以 JS 的名义来好好查查你 - 前端 - 掘金](https://juejin.im/entry/58f484af570c350056410bc8)
* [JavaScript 浮点数陷阱及解法 · Issue #9 · camsong/blog](https://github.com/camsong/blog/issues/9)
* [Double-precision floating-point format - Wikipedia](https://en.wikipedia.org/wiki/Double-precision_floating-point_format#cite_note-whyieee-1)
* [subnormal number double precision - Google 搜索](https://www.google.com/search?newwindow=1&sxsrf=ACYBGNQos_1qIrIO8J5IKQO8l0aECyb0zA%3A1573736453371&ei=BVDNXY2mFqS1mAXO9quYDw&q=subnormal+number+double+precision&oq=subnormal+double+&gs_l=psy-ab.3.0.0i8i30l3.838923.850658..853895...2.0..0.100.1048.11j1......0....1j2..gws-wiz.......0i203j0i30j0i10i30j0i5i30j0i8i10i30j0i10.AMR50EfVLf8)
* [说说 JavaScript 中的数字 - ZhusCafe](https://zhuscat.com/posts/javascript-number)
* [Number.MIN_VALUE - JavaScript | MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MIN_VALUE)
* [javascript 的精度问题 | FatShen's Blog](https://fatshen3.cn/2018/05/29/javascript-float/)
* [Numbers in JavaScript](http://jser.it/blog/2014/07/07/numbers-in-javascript/)
* [JavaScript 中的 Number – Clloz-素直になれない](https://www.clloz.com/programming/front-end/js/2019/06/11/javascript-number/)
