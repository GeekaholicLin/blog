# 页面置换算法（缓存淘汰算法）

当出现缺页异常需调入新页面而内存已满的时候，页面置换算法需尽可能减少页面的调入调出次数，把未来不再需要访问或短期内不访问的页面调出。

对应在业务中的使用场景是缓存空间有限，需要使用页面置换算法将不再需要访问或短期内不访问的缓存淘汰。

## OPT-最佳置换算法

选择在内存中以后不再被访问，或者在最长时间内不再被访问的页面进行置换，这样可以保证最低的缺页率。（缺页率 = 访问页面时没有命中的次数 / 访问次数）

这种算法无法实现，因为无法预知未来，但是可以用于标准进行其他页面置换算法的评估。

## FIFO-先进先出算法

FIFO，全称为「First-In First-Out」，先进先出算法

> 核心思想：如果一个数据最先进入缓存中，则应该最早淘汰掉

实现简单（队列），但是有可能被调出的页面是经常访问的，导致较高的缺页率。

## LFU-最不常用算法

LFU，全称「Least Frequently Used」，最不常用算法

> 核心思想：如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小

每个页面设置一个访问计数，访问页面时，访问计数加 1，缺页时，置换计数最小的页面。

缺点：开始时频繁使用，但以后不使用的页面很难置换。

## LRU-最近最久未使用

LRU，全称「Least Recently Used」，最近最久未使用算法。

> 核心思想：如果数据最近被访问过，它在未来也极有可能访问过

LRU 性能接近 OPT，且是常用的缓存淘汰算法。

缺页时，计算内存中每个逻辑页面的上一次访问时间，选择上一次使用到当前时间最长的页面。因为如果某些页面长时间未被访问，则它们在将来还可能会长时间不会访问。

LRU 算法优势在于算法实现难度不大，对于热点数据， LRU 效率会很好。

LRU 算法劣势在于对于偶发的批量操作，比如说批量查询历史数据，就有可能使缓存中热门数据被这些历史数据替换，造成缓存污染，导致缓存命中率下降，减慢了正常数据查询。

### LRU 算法实现

// TODO:

### LRU 改进方案

### LRU 改进的对比

// TODO:

## 拓展

redis 中的缓存淘汰策略有 6 种：

- `noeviction`：不删除策略，达到最大内存限制时，如果需要更多内存，直接返回错误信息。
- `allkeys-lru`：所有 key 通用，优先删除最近最少使用 (LRU) 的 key。
- `volatile-lru`：只限于设置了 expire 的部分；优先删除最近最少使用 (LRU) 的 key。
- `allkeys-random`：所有 key 通用；随机删除一部分 key。
- `volatile-random`：只限于设置了 expire 的部分；随机删除一部分 key。
- `volatile-ttl`：只限于设置了 expire 的部分；优先删除剩余时间 (time to live,TTL) 短的 key。

---

参考：

- [常见缓存淘汰算法 — 孙不服的博客](https://www.sunbufu.club/2019/01/26/cache-eviction/#22-lru%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E8%A2%AB%E4%BD%BF%E7%94%A8)
- [缓存淘汰算法 – LRU – 碎言碎语](https://johng.cn/lru-brief/)
